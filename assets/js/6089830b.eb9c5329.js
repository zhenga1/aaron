"use strict";(self.webpackChunkaaronzheng=self.webpackChunkaaronzheng||[]).push([[7845],{3905:(e,n,r)=>{r.d(n,{Zo:()=>i,kt:()=>f});var a=r(7294);function t(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function c(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?c(Object(r),!0).forEach((function(n){t(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):c(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,a,t=function(e,n){if(null==e)return{};var r,a,t={},c=Object.keys(e);for(a=0;a<c.length;a++)r=c[a],n.indexOf(r)>=0||(t[r]=e[r]);return t}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)r=c[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var o=a.createContext({}),p=function(e){var n=a.useContext(o),r=n;return e&&(r="function"==typeof e?e(n):s(s({},n),e)),r},i=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,c=e.originalType,o=e.parentName,i=l(e,["components","mdxType","originalType","parentName"]),m=p(r),d=t,f=m["".concat(o,".").concat(d)]||m[d]||u[d]||c;return r?a.createElement(f,s(s({ref:n},i),{},{components:r})):a.createElement(f,s({ref:n},i))}));function f(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var c=r.length,s=new Array(c);s[0]=d;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[m]="string"==typeof e?e:t,s[1]=l;for(var p=2;p<c;p++)s[p]=r[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},1053:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>m,frontMatter:()=>c,metadata:()=>l,toc:()=>p});var a=r(7462),t=(r(7294),r(3905));const c={},s=void 0,l={unversionedId:"CS61A/misc/useless scheme",id:"CS61A/misc/useless scheme",title:"useless scheme",description:"Actually kinda useful",source:"@site/docs/CS61A/misc/useless scheme.md",sourceDirName:"CS61A/misc",slug:"/CS61A/misc/useless scheme",permalink:"/aaronzheng/docs/CS61A/misc/useless scheme",draft:!1,editUrl:"https://github.com/zhenga1/aaronzheng/tree/main/docs/CS61A/misc/useless scheme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"tree_representation",permalink:"/aaronzheng/docs/CS61A/misc/tree_representation"},next:{title:"sp21 final",permalink:"/aaronzheng/docs/CS61A/sp21 final"}},o={},p=[],i={toc:p};function m(e){let{components:n,...r}=e;return(0,t.kt)("wrapper",(0,a.Z)({},i,r,{components:n,mdxType:"MDXLayout"}),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"\xa0 `((define (func exp) (if (= nil exp) (nil) (append (car exp) (cdr exp))))\n\n\xa0 (if ,condition (append 'begin func(,exprs)) (print 'okay)))\n`(if ,condition (begin (car ,exprs)))\n\n`(if ,condition (append '(begin) ,exprs) (print 'okay))\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"\xa0 (if (= (eval expr) (car (car cases))) (cdr (car cases)) (switch expr (cdr cases)))\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-macro (switch expr cases)\n\n\xa0 (cons eval\n\n\xa0 \xa0 (map ( (lambda (case) (= (car case) (eval expr))) (cons _________ (cdr case)))\n\n\xa0 \xa0 \xa0 \xa0 \xa0 cases)\n\n\xa0 )\n\n)\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-macro (switch expr cases)\n\n\xa0 \xa0 (cons eval\n\n\xa0 \xa0 \xa0 \xa0 (map (lambda (case) (= (eval expr) (car case)) (cons list (cdr case)))\n\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 cases))\n\n)\n")),(0,t.kt)("p",null,"Actually kinda useful"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"\xa0 \xa0 (cons 'eval\n\n\xa0 \xa0 \xa0 \xa0 (map (lambda (case) (cons `(if (not (= (car ,case) ,expr)) nil) (cdr case)))\n\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 cases))\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"\xa0 \xa0 (cons 'eval\n\xa0 \xa0 (map (lambda (case) (cons (if (not (= (car case) expr)) nil) (cdr case)))\n\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 cases))\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"\xa0 \xa0 (cons 'eval\n\n\xa0 \xa0 \xa0 \xa0 (map (lambda (case) (cons (list 'if (list = (car case) (expr)) nil 'eval)\n\n\xa0 \xa0 \xa0 \xa0 \xa0(cdr case)))\n\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 cases)\n\n\xa0 \xa0 )\n")),(0,t.kt)("p",null,"Working scheme code:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"(if (eval condition) (append (list 'begin) exprs) (print 'okay))\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"\xa0 \xa0 (cons 'begin\n\n\xa0 \xa0 (map (lambda (case) (cons\n\n\xa0 \xa0 (cons 'if\n\n\xa0 \xa0 (cons =\n\n\xa0 \xa0 (cons (list (car case))\n\n\xa0 \xa0 (cons expr\n\n\xa0 \xa0 nil)))) (cdr case))) cases\n\n\xa0 \xa0 )\n\n\xa0 \xa0 )\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"((= (cdr s) nil) (car s))\n\n\xa0 ((pred (car s)) (cons (car s) (my-filter pred (cdr s))))\n\n  \n\n\xa0(else (my-filter pred (cdr s)))\n\n\xa0)\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-scheme"},"(+ (joiner start (term n)) (accumulate joiner 0 (- n 1) term))\n")))}m.isMDXComponent=!0}}]);